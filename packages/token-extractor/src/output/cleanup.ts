import { AuditResult, AuditIssue } from './audit';

export type TaskPriority = 'priority1' | 'priority2' | 'priority3';

export interface CleanupTask {
  description: string;
  files?: string[];
  tokens?: string[];
  suggestedFix?: string;
  category: string;
}

export interface CleanupTasks {
  priority1: CleanupTask[]; // Critical
  priority2: CleanupTask[]; // Important (warnings)
  priority3: CleanupTask[]; // Enhancements (info)
}

/**
 * Generates prioritized cleanup tasks from audit results
 */
export class CleanupTaskGenerator {
  private auditResult: AuditResult;

  constructor(auditResult: AuditResult) {
    this.auditResult = auditResult;
  }

  /**
   * Generate prioritized cleanup tasks
   */
  public generateTasks(): CleanupTasks {
    const tasks: CleanupTasks = {
      priority1: [],
      priority2: [],
      priority3: [],
    };

    this.auditResult.issues.forEach(issue => {
      const task = this.issueToTask(issue);

      if (issue.severity === 'critical') {
        tasks.priority1.push(task);
      } else if (issue.severity === 'warning') {
        tasks.priority2.push(task);
      } else if (issue.severity === 'info') {
        tasks.priority3.push(task);
      }
    });

    return tasks;
  }

  /**
   * Convert audit issue to cleanup task
   */
  private issueToTask(issue: AuditIssue): CleanupTask {
    return {
      description: issue.description,
      files: issue.files,
      tokens: issue.tokens,
      suggestedFix: issue.suggestion,
      category: issue.category,
    };
  }

  /**
   * Generate markdown checklist
   */
  public generateMarkdown(): string {
    const tasks = this.generateTasks();
    const lines: string[] = [];

    // Header
    lines.push('# Design System Cleanup Tasks');
    lines.push('');
    lines.push('Generated from design system health audit.');
    lines.push('');

    // Priority 1: Critical
    const p1Count = tasks.priority1.length;
    lines.push(`## Priority 1: Critical (${p1Count} ${p1Count === 1 ? 'task' : 'tasks'})`);
    lines.push('');

    if (p1Count === 0) {
      lines.push('No critical issues found.');
      lines.push('');
    } else {
      tasks.priority1.forEach(task => {
        lines.push(...this.formatTask(task));
      });
    }

    // Priority 2: Important
    const p2Count = tasks.priority2.length;
    lines.push(`## Priority 2: Important (${p2Count} ${p2Count === 1 ? 'task' : 'tasks'})`);
    lines.push('');

    if (p2Count === 0) {
      lines.push('No important issues found.');
      lines.push('');
    } else {
      tasks.priority2.forEach(task => {
        lines.push(...this.formatTask(task));
      });
    }

    // Priority 3: Enhancements
    const p3Count = tasks.priority3.length;
    lines.push(`## Priority 3: Enhancements (${p3Count} ${p3Count === 1 ? 'task' : 'tasks'})`);
    lines.push('');

    if (p3Count === 0) {
      lines.push('No enhancement suggestions.');
      lines.push('');
    } else {
      tasks.priority3.forEach(task => {
        lines.push(...this.formatTask(task));
      });
    }

    // Footer
    lines.push('---');
    lines.push('');
    lines.push('Generated by @handoff/token-extractor');

    return lines.join('\n');
  }

  /**
   * Format a task as markdown
   */
  private formatTask(task: CleanupTask): string[] {
    const lines: string[] = [];

    // Checkbox and description
    lines.push(`- [ ] ${task.description}`);

    // File references
    if (task.files && task.files.length > 0) {
      const uniqueFiles = [...new Set(task.files)];
      uniqueFiles.forEach(file => {
        lines.push(`  File: \`${file}\``);
      });
    }

    // Token references
    if (task.tokens && task.tokens.length > 0) {
      lines.push(`  Tokens: ${task.tokens.map(t => `\`${t}\``).join(', ')}`);
    }

    // Suggested fix
    if (task.suggestedFix) {
      lines.push(`  Fix: ${task.suggestedFix}`);
    }

    lines.push('');

    return lines;
  }
}
